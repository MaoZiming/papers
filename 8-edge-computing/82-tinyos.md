# System Architecture Directions for Networked Sensors (2000)

Link: https://pdos.csail.mit.edu/archive/6.097/readings/tinyos.pdf

Read: June 28th, 2024.

Traditional OS models were not fit for the constrained resources available on low-power, integrated networked sensor nodes. TinyOS is a tiny **event-driven** operating system that provides support for efficient modularity and **concurrency-intensive** operation that fits for this context. 

Discusison on hardware:
* Small physical size, modest active power load and tiny inactive load are provided by the hardware design.

_The key requirements_ under this type of low power wireless communication environment are
* _Resource Efficiency_: Sensor nodes are constrained by power, computation, and storage resources
* _Modularity_: Easy to compose yet sufficiently decoupled components.
* _Fine-grained concurrency_: sensing, processing, and communication
    * information may be simultaneously captured from sensors, manipulated, and streamed onto a network 

## Key Ideas 
* Support concurrency
    * **Event-driven** architecture: high performance in concurrency intensive application! 
      * No polling.
      * Unused CPU cycles are spent in the sleep state as opposed to actively looking for an interesting event. 
    * Why not thread?
       * stack-based: reserved for each execution context
       * need to be multi-task between execution contexts at rate of **40,000 switches per second**
* Software modularity
    *  Application = scheduler + graph of components
    *  _Component_: command handlers, event handlers, fixed-size frame, simple tasks
        * declare commands it uses and events it signals
        * provide interfaces used by other components to communicate with it  
    *  _Scheduler_: schedules the components 
*  Efficiency
    *  Get done quickly and then sleep
    *  Static memory allocation
        *  No heap (malloc), no function pointers, no dynamic runtime allocation    

### Component
A component is an independent computational entity that exposes one or more interfaces. It has the following four interrelated parts: 

* Frame (storage) 
* A set of command handlers: cause actions to be initiated 
   * deposit request parameters into frame, post tasks 
* Event: 
   * notify action has occured
   * generated by external interrupts
   * call back to provide results from previous commands 
* A bundle of simple tasks (computation): perform the primary work
   * background computation, not time critical 
   * task scheduler: FIFO  
* Layers of components: higher level components issue commands to lower level components, and lower level components signal events to the higher level components. 
* TinyOS achieves high concurrency by allowing tasks and events to run in small, non-blocking chunks, which allows the system to handle multiple operations 'simultaneously' without needing a heavy-weight OS layer

## Compared 
* TinyOS: The problem we must tackle is strikingly similar to that of building efficient network interfaces, which also must maintain a large number of concurrent flows and juggle numerous outstanding events

* Thread-based model: scheduler activations, cappricio
* Event-based system like TinyOS: SEDA
* Monolithic architecture class 


## Questions

* How is fine-grained concurrency achieved?
    * Multi-source of events: sensor reading, network messages, etc.
    * Event-driven model: appropriate event handler is triggered
    * Tasks as units of work: when event initiates responses
    * Command chain: layer by layer (each command is a small piece of the overall operation)
    * Integration with physical hardware (wrapped in commands and event handlers)
    * Avoiding blocking operations

* Static Frame allows us to know the memory footprint at compile time; as well as knowing the variable locations statically at compile time rather than accessing state via pointers. 

* The communication across the components takes the form of a function call, which has low overhead and provides compile time type checking.

## Limitations

* Scalability and performance
    * lightweight design and event-driven model may not suit the apps with high-performance requirements or those that need to scale to larger networks
* Difficult to program
    * CPU-intensive application can cause a problem (i.e. break it down into $N$ separate computations)
# System Architecture Directions for Networked Sensors (2000)

Link: https://pdos.csail.mit.edu/archive/6.097/readings/tinyos.pdf

Read: June 28th, 2024.


Traditional OS models were not fit for the constrained resources available on low-power, integrated networked sensor nodes. TinyOS is a tiny **event-driven** operating system that provides support for efficient modularity and **concurrency-intensive** operation that fits for this context. 

 A lot of discussions on the hardware. 

_The key requirements_ under this type of low power wireless communication environment are
1. _Resource Efficiency_: Sensor nodes are constrained by power, computation, and storage resources
2. _Modularity_: Easy to compose yet sufficiently decoupled components.
3. _Fine-grained concurrency_: sensing, processing, and communication
    1. information may be simultaneously captured from sensors, manipulated, and streamed onto a network 


## Key Ideas 
* Support concurrency
    * Event-driven architecture: high performance in concurrency intensive application! 
    * Why not thread?
       * stack-based: reserved for each execution context
       * need to be multi-task between execution contexts at rate of 40,000 switches per second  
* Software modularity
    *  Application = scheduler + graph of components
    *  _Component_: command handlers, event handlers, fixed-size frame, simple tasks
        * declare commands it uses and events it signals
        * provide interfaces used by other components to communicate with it  
    *  _Scheduler_: schedules the components 
*  Efficiency
    *  Get done quickly and then sleep
    *  Static memory allocation
        *  No heap (malloc), no function pointers, no dynamic runtime allocation    

### Component
A component is an independent computational entity that exposes one or more interfaces 

* Frame (storage) 
* Command: cause actions to be initiated 
   * deposit request parameters into frame, post tasks 
* Event: 
   * notify action has occured
   * generated by external interrupts
   * call back to provide results from previous commands 
* Task (computation): perform the primary work
   * background computation, not time critical 
   * task scheduler: FIFO  


TinyOS achieves high concurrency by allowing tasks and events to run in small, non-blocking chunks, which allows the system to handle multiple operations 'simultaneously' without needing a heavy-weight OS layer

## Compared 
> TinyOS: The problem we must tackle is strikingly similar to that of building efficient network interfaces, which also must maintain a large number of concurrent flows and juggle numerous outstanding events

* Thread-based model: scheduler activations, cappricio
* Event-based system like TinyOS: SEDA
* Monolithic architecture class 


## Questions

- How is fine-grained concurrency achieved?
    - Multi-source of events: sensor reading, network messages, etc.
    - Event-driven model: appropriate event handler is triggered
    - Tasks as units of work: when event initiates responses
    - Command chain: layer by layer (each command is a small piece of the overall operation)
    - Integration with physical hardware (wrapped in commands and event handlers)
    - Avoiding blocking operations
    - Scheduler’s role
- Why can it be non-blocking?
- Single-hardware thread? or more than one hardware thread?
    - Tasks atomic? —> yes
- Compared to Capriccio?
    - Thread models with bounded stack size?
        - Not send the signal and buffer within your stack? —> maybe buffering takes lots of space

- Frame allows us to know the memory footprint at compile time; as well as knowing the variable locations statically at compile time rather than accessing state via pointers. 

- The communication across the components takes the form of a function call, which has low overhead and provides compile time type checking.

## Limitations

- Scalability and performance
    - lightweight design and event-driven model may not suit the apps with high-performance requirements or those that need to scale to larger networks
- Difficult to program
    - CPU-intensive application can cause a problem (i.e. break it down into N separate computations)
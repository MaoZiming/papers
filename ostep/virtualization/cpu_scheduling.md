# Scheduling

- Assumptions:
  - Each job runs for the same amount of time
  - All jobs arrive at the same time.
  - Once started, each job runs to completion.
  - All jobs only use the CPU (i.e., they perform no I/O)
  - The run-time of each job is known.
- Scheduling metrics:
  - Turnaround time: the time at which the job completes
    - $T_{turnaround} = T_{completion} - T_{arrival}$
    - the time which the job arrived in the system 
  - Another metric: fairness, e.g. Jain’s Fairness Index 
  - Why is FIFO not great?
    - Convoy effect: # of relatively-short potential consumers of a resource get queued behind a heavyweight resource consumer 
  - SJF: If all jobs arrive at the same time, SJF is an **optimal** scheduling algorithm
    - However, if jobs arrive at different time:
      - Same convey problem
  - STCF: 
    - If we do not requite all jobs to run to completion:
    - Add **preemption** 
      - Any time a new job enters the system, the STCF scheduler determines which of the re- maining jobs (including the new job) has the least time left, and schedules that one. 
    - Better average turnaround time 
      - Given the new assumptions, STCF is provably optimal 
  - Response time: the time from when the job arrives in a system to the first time it is scheduled 
    - $T_{response} = T_{firstrun} - T_{arrival} $
  - SJF and STCF:
    - Bad for response time
  - Round Robin (Good for response time.)
    - Time-slicing
    - Runs the job for a time slice (or a scheduling quantum); switch to the next job in the run queue.
    - The shorter the time is, the better performance of RR under response time metric
    - Too short: cost of context switching dominates (i.e. CPU caches, TLBs, branch predictors, and other on-chip hardware)
    - Because turnaround time only cares about when jobs finish, RR is nearly pessimal, even worse than simple FIFO in many cases 
      - RR is worse for turnaround time. 
    - Any policy that is fair —> but perform poorly on metrics such as turnaround time
        - willing to be unfair —> run shorter jobs to completion, but at the cost of the response time
        - value fairness —> response time is lowered, but at the cost of the turnaround time
  - Incorperating I/O: overlapping leads to better use of resources. 
    - currently-running job won’t be using the CPU dur- ing the I/O; it is blocked waiting for I/O completion. 
    - The scheduler also has to make a decision when the I/O completes. When that occurs, an interrupt is raised, and the OS runs and moves the process that issued the I/O from blocked back to the ready state. Of course, it could even decide to run the job at that point. 
  - ![alt text](job_scheduling.png)
    - A common approach is to treat each 10-ms sub-job of A as an indepen- dent job. Thus, when the system starts, its choice is whether to schedule a 10-ms A or a 50-ms B. With STCF, the choice is clear: choose the shorter one, in this case A. Then, when the first sub-job of A has completed, only B is left, and it begins running. Then a new sub-job of A is submitted, and it preempts B and runs for 10 ms.
  
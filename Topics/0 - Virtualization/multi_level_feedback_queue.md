# Multi-Level Feedback Queue

- Two problems:
  - It would like to optimize turnaround time 
  - It would like to make a system feel responsive to interactive users, thus minimize response time 
- the MLFQ has a number of distinct queues, each assigned a different priority level
- Two rules
  - Rule 1: If Priority(A) > Priority(B), A runs (B doesn't)
  - Rule 2: If Priority(A) = Priority(B), A \& B run in RR
- MLFQ varies the priority of a job based on its observed behavior 
  - “learn” about processes as they run 
  - use the “history” to predict “future” behavior 
- Job’s allotment. The allotment is the amount of time a job can spend at a given priority level before the scheduler reduces its priority.
- Attempt 1: how to change priority 
  - Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue)
  - Rule 4a: If a job uses up its allotment while running, its priority is reduced (i.e., it moves down one queue)
  - Rule 4b: If a job gives up the CPU before the allotment is up, it stays at the same priority level. (allotment is reset)
    - if an interactive job, for example, is doing a lot of I/O (say by waiting for user input from the keyboard or mouse), it will relinquish the CPU before its time slice is complete; in such case, we don’t wish to penalize the job and thus simply keep it at the same level.
  - Approximate SJF 
  - Problem 
    - Starvation: too many interactive jobs in the system, then combine to consume all CPU time; long-running job starves 
    - Smart user: game the scheduler (e.x. before the time slice is over, issue an I/O operation). A job could monopolize the CPU.
    - A program might change its behavior over time. What was CPU bound may transition to a phase of interactivity.  
- Attempt #2: Priority Boost 
  - Rule 5: After some time period S, move all the jobs in the system to the topmost queue.
  - John Ousterhout, voo-doo constants (S): requring black magic to set the value correctly 
    - S is too high: long-running jobs could starve 
    - S is too low: interactive jobs may not get a proper share of the CPU 
- Attempt #3: Better Accounting 
  - How to prevent gaming of the scheduler? 
  - Rule 4: Once a job uses up its time allotment at a given level (regardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).
- One big issue is parameterization: For example, how many queues should there be? How big should the time slice be per queue? The allotment? How often should priority be boosted in order to avoid starvation and account for changes in behavior? 
- Most MLFQ variants allow for varying time-slice length across different queues.
- decay-usage algorithm: FreeBSD scheduler (version 4.3) uses a formula to calculate the current priority level of a job, basing it on how much CPU the process has used; in addition, usage is decayed over time, providing the desired priority boost in a different manner than described herein. 
- Some systems also allow some user advice to help set priorities; for example, by using the command-line utility nice you can increase or decrease the priority of a job (somewhat)
# Complete VM systems

- The Page Cache
  - The Linux page cache is unified, keeping pages in memory from three primary sources: memory-mapped files, file data and metadata from de- vices (usually accessed by directing read() and write() calls to the file system), and heap and stack pages that comprise each process (sometimes called anonymous memory, because there is no named file underneath of it, but rather swap space). These entities are kept in a page cache hash table, allowing for quick lookup when said data is needed.
  - The page cache tracks if entries are clean (read but not updated) or dirty (a.k.a., modified). Dirty data is periodically written to the back- ing store (i.e., to a specific file for file data, or to swap space for anony- mous regions) by background threads (called pdflush), thus ensuring that modified data eventually is written back to persistent storage.
- Buffer overflow attack;
- The idea is known, in its most general form, as return-oriented programming (ROP) [S07], and really it is quite brilliant. The observation behind ROP is that there are lots of bits of code (gadgets, in ROP terminology) within any program’s address space, es- pecially C programs that link with the voluminous C library. Thus, an attacker can overwrite the stack such that the return address in the cur- rently executing function points to a desired malicious instruction (or series of instructions), followed by a return instruction. By stringing to- gether a large number of gadgets (i.e., ensuring each return jumps to the next gadget), the attacker can execute arbitrary code. Amazing!
- Linux (and other systems) add another defense, known as address space layout randomization (ASLR). Instead of placing code, stack, and the heap at fixed locations within the virtual address space, the OS randomizes their placement, thus making it quite challenging to craft the intricate code sequence required to implement this class of attacks.
- One class of technique that lies at the core of the problem is called speculative execution, in which the CPU guesses which instructions will soon be executed in the future, and starts executing them ahead of time. If the guesses are correct, the pro- gram runs faster; if not, the CPU undoes their effects on architectural state (e.g., registers) and tries again, this time going down the right path.
- One avenue to increasing kernel protection was thus to remove as much of the kernel address space from each user process and instead have a separate kernel page table for most kernel data (called kernel page- table isolation, or KPTI) [G+17]. Thus, instead of mapping the kernel’s code and data structures into each process, only the barest minimum is kept therein; when switching into the kernel, then, a switch to the kernel page table is now needed.
